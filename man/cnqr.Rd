% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cnqr.R
\name{cnqr}
\alias{cnqr}
\title{Fit a full vine model space using CNQR}
\usage{
cnqr(edges, dat, sc, basevine, cdf = identity, QY = identity,
  copspace = NULL, refit = FALSE, verbose = FALSE,
  families = c("indepcop", "bvncop", "bvtcop", "mtcj", "gum", "frk", "joe",
  "bb1", "bskewncop", "bskewncopp"))
}
\arguments{
\item{edges}{Integer vector starting with the column number of the response
variable, followed by the column numbers of the predictors to use,
in the order that they are to be linked with the response.}

\item{dat}{Data frame or matrix containing the data (columns=variables), or
a list of such data frames. In the latter case, the first data frame is
used for parameter estimation (training data), the second data
frame is used for copula selection (validation data), and all other
data are not used in the fitting procedure, but are included in the
output. \code{dat} may
also be a single vector of response data, in the case you
have no predictors.}

\item{sc}{Scoring rule to use for the regression, as in the output
of \code{\link{scorer}}.}

\item{basevine}{Object of type \code{'rvine'} containing
the predictors, and not the response. If left blank, the predictors are
assumed to be independent.}

\item{cdf}{List of vectorized distribution functions of the data, where
the entries correspond respectively to the columns in the data frames in
\code{dat}. Or, if the distribution functions are all the same, \code{cdf}
can be that single function. You can ignore this argument if you don't
include any predictors in \code{edges}.}

\item{QY}{Quantile function of the response, which accepts a
vector of values (quantile levels) in (0,1). It should return
quantiles, either in the form of
a vector corresponding to the input,
or in the form of a matrix with columns corresponding to the inputted
quantile levels and rows corresponding to the observations
(thus allowing for each observation of the response to come from different
distributions).}

\item{copspace}{List with vector entries of the copula families to try fitting
for each edge. \code{NULL} entries will be replaced with all copula families
in \code{families}. Or, leave the argument as \code{NULL} to fit all families in
\code{families} for all edges.}

\item{refit}{After all the copula models have been selected and fit
(this is done sequentially), should the parameters of those copula
families be re-estimated, but this time altogether, using all the data?
\code{TRUE} if so.}

\item{verbose}{Logical; should messages be output to indicate what
\code{cnqr} is doing?}

\item{families}{Vector of copula families.
For those edges in \code{cop} that don't have copula families
specially selected (i.e. have \code{NULL} entries), these families are used.}
}
\value{
An object of class \code{'cnqr'}, which is also an object of type
\code{'rvine'} containing the final fitted vine.
In addition to the list entries present in \code{'rvine'}
objects, a \code{'cnqr'} object has the following named entries:

\describe{
     \item{y}{List of response vectors.}
     \item{uind}{List of matrices of independent predictors.}
     \item{QY}{Either a list of quantile functions, or a vectorized
     quantile function. In the latter case, the marginal distribution
     is stationary -- that is, does not differ depending on the observation.}
     \item{cdf}{List of vectorized distribution functions, corresponding
     to the columns of the data frames/matrices inputted.}
     \item{yhat}{List of matrices of quantile predictions. Matrix columns
     correspond to the quantile levels, and rows correspond to observations.}
     \item{scorer}{The scoring rule used for the regression, as in the output
     of \code{\link{scorer}}.}
     \item{score}{A named vector of scores, one entry per data type.}
}

Except for \code{$scorer} and possibly \code{$QY} (if response data
are stationary), each entry is a list/vector
corresponding to a different type of data set. The first one is always the
training data, named \code{"tr"}. If a second
data matrix is supplied in \code{dat}, the
second entry will correspond to this (the "validation
data"), and is named \code{"val"}.
Additional data supplied through \code{dat} will also appear in these lists,
and either be named according to their names in \code{dat}, or if
unnamed, will have the names \code{'dat3'}, \code{'dat4'}, etc.
The vector in \code{$score} also corresponds to these data sets.
}
\description{
Uses CNQR to estimate/select a vine from a general model space. That is,
selects and estimates a copula family for each link between parameter
and response.
}
\examples{
data(egdat)
dat <- list(egdat[1:750, ], egdat[751:1000, ])
basevine <- subset(egvine, 1:4)
sc <- scorer(space_taus(10))

summary(cnqr(5:1, dat, sc, basevine=basevine))
summary(cnqr(5, dat, sc))

set.seed(123)
newdat <- rrvine(100, egvine)
dat <- c(dat, list(test=newdat))
fit <- cnqr(5:3, dat, sc, basevine=basevine,
            families=c("bvncop", "joe"))
summary(fit)
}
