% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cnqr_est.R
\name{cnqr_est}
\alias{cnqr_est}
\title{Estimate Vine Parameters using CNQR}
\usage{
cnqr_est(rv, a, cop, cpar_init, sc, y, uind, QY = identity)
}
\arguments{
\item{rv}{Object of type \code{'rvine'}, to be augmented.}

\item{a}{Vector of variable numbers (of the predictors) to augment to the
end of the array of \code{rv} (i.e., the last column).}

\item{cop}{Character vector of copulas to augment \code{rv} with
(with reflections already chosen). Each entry corresponds to a new
edge/row in the vine (corresponding to \code{a}).}

\item{cpar_init}{Starting values for the copula families in \code{cop}.
Should be a list with entries being parameter vectors.}

\item{sc}{Scoring rule to use for the regression, as in the output
of \code{\link{scorer}}.}

\item{y}{Vector of response data.}

\item{uind}{Matrix of independent uniform predictors,
as in the output of \code{\link{pcondseq}}, of the predictors
up to the last entry in \code{a}.
So, if "\code{b}" is the non-zero entries of the last column of the array
in \code{rv} after removing the first variable (the response) and
appending \code{a}, the matrix will be the PIT scores of variables
\code{b[1]}; \code{b[2]|b[1]}; \code{b[3]|b[1:2]}; etc.}

\item{QY}{Quantile function of the response \code{y}, which accepts a
vector of values (quantile levels) in (0,1). It should return
quantiles, either in the form of
a vector corresponding to the input,
or in the form of a matrix with columns corresponding to the inputted
quantile levels and rows corresponding to the observations of \code{y}
(thus allowing for each value in \code{y} to come from different
distributions).}
}
\value{
Returns a list of copula parameters (the same structure
as \code{cpar_init}), estimated with CNQR.
}
\description{
Estimate copula parameters using CNQR. More specifically, for a given
object of type \code{'rvine'} that you would like to extend by adding
more rows to its last column, estimates the parameters for the
specified copula families of each edge.
}
\details{
Here's how the estimation is done.

\enumerate{
     \item You begin with a vine \code{rv}, where the top-right corner
     of the array is the response variable. There may or may not be
     variables (representing the predictors) underneath this response. Note
     that, to be able to condition the response on predictors, those
     predictors must appear below the response variable in the vine array.
     \item Your objective is to add more variables (predictors, already
     existing in the vine) to the last column of the vine array. Package
     these additional variables in the argument \code{a}, with
     corresponding copula families \code{cop}.
     \item The copula parameters of \code{cop} need estimation. This is done
     by optimizing quantile predictions of the response,
     conditional on the predictors in \code{a} AND the predictors
     already listed below the response in the vine array of \code{rv}.
     \item The "optimization" in the previous step refers to optimizing a
     scoring rule, which is indicated in the \code{sc} argument.
}
}
\examples{
## Read in some data
data(egdat) # Data `egdat`, generated by the rvine `egvine`.

## Pretend we know the model for the predictors 1:4:
rv <- subset(egvine, 1:4)

## Add the predictor, for regression:
rv <- augment(rv, a=5)
summary(rv)

## We'll link the response to predictor 4, then 3, using
##  the appropriate copulas.
#### Model space:
a <- c(4, 3)
(cop <- egvine$copmat[1:2, 5])
cpar_init <- egvine$cparmat[1:2, 5]
#### Independent uniform predictors
uind <- pcondseq(egdat, c(4, 3), rv)

## Do the regression:
(cparhat <- cnqr_est(rv, a, cop, cpar_init,
                       sc=scorer(space_taus(10)),
                       y=egdat[, 5],
                       uind=uind))

## Compare to the truth:
cpar_init

## Augment this to the working vine (rv):
rv <- augment(rv, a=a, cop=cop, cpar=cparhat)

## Try fitting another variable (2) with independence:
cnqr_est(rv, 2, "indepcop", list(numeric(0)),
           sc=scorer(space_taus(10)),
           y=egdat[, 5],
           uind=uind)

## Try fitting no variables:
cnqr_est(rv, a=integer(0))
}
\seealso{
\code{\link{cnqr_sel}} for CNQR when the model space is a
finite selection of vines.
}
