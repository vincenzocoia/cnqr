% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calibration.R
\name{calibration}
\alias{calibration}
\alias{calplot.cnqr}
\title{Calibration of a Forecast}
\usage{
calibration(y, yhat, tau, w = 1, hist = FALSE, disp_plot = TRUE)

\method{calplot}{cnqr}(obj, dat = "tr", tau = NULL, QY = NULL, w = 1,
  hist = FALSE, disp_plot = TRUE)
}
\arguments{
\item{y}{Vector of outcomes/response.}

\item{yhat}{Matrix of forecasts. Each row is a forecast corresponding to
\code{y}; each column corresponds to a quantile index.}

\item{tau}{Vector of the quantile indices forecast.}

\item{w}{Vector of weights for each observation. Not necessarily normalized.}

\item{hist}{Logical; should values for a calibration histogram be computed
(\code{TRUE}), instead of for a survival function (\code{FALSE})? If
\code{TRUE}, then \code{tau} defines the left-endpoints of the bins.}

\item{disp_plot}{Logical; should a P-P plot be output?}

\item{obj}{Object of type \code{'cnqr'}. See \code{\link{cnqr}}.}

\item{dat}{Data matrix or data frame with raw data.
Or, a character vector specifying data that's already in \code{'obj'} --
for example, \code{"tr"} for the training data (always present), or
\code{"val"} for validation data. All data specified in the character
vector will be pooled.}
}
\value{
A data frame.

When \code{hist} is \code{TRUE}, the columns have names \code{"left"}
and \code{"right"}, for the left and right endpoints of the histogram bins
(which are quantile levels),
and \code{"hist"}, for the proportion of observations falling in the bin
(right-endpoint inclusive).

When \code{hist} is \code{FALSE}, the columns have names \code{"ind"}
for the quantile levels, and \code{"exc"} for the proportion of
outcomes exceeding that quantile.
}
\description{
Computes the proportion of quantile forecasts that are exceeded, for each
quantile specified. Or, computes a histogram of probability integral
transformed observations. \code{calplot.cnqr} produces the calibration
plots from a fitted \code{'cnqr'} object, so that you don't need to
compute \code{yhat}, as you would with \code{calibration}.

The calibration plot is defined as the plot of P(Q(tau) > tau) over tau.
It can be thought of as the empirical survival function of F_hat(y_obs),
where F_hat is the forecasted cdf, and y_obs is the observation. We can
evaluate it at a bunch of taus by seeing how many observations exceed
the tau forecasts.
}
\details{
By extension, a calibration _histogram_ can be defined as a histogram
of the F_hat(y_obs) values. Choosing bin boundaries (tau_c, tau_1, tau_2, ..., 1),
we can compute the height of each bar as the difference in survival function
between the two endpoints of the bin, which tells us how many observations
lie in that bin (divided by number of F_hat(y_obs)'s that exceed tau_c).
}
\examples{
data(egdat)
dat <- list(egdat[1:750, ], egdat[751:1000, ])
basevine <- subset(egvine, 1:4)
sc <- scorer(space_taus(10))
fit <- cnqr(5:4, dat, basevine, sc=sc)

calplot(fit)
calibration(dat[[1]][, 5], predict(fit), tau=fit$scorer$tau)
calplot(fit, tau=space_taus(100))
}
