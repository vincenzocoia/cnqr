% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gpdqr.R
\name{gpdqr}
\alias{gpdqr}
\title{Evaluate Quantile Surfaces with GPD Tail}
\usage{
gpdqr(object, newdata, tau_thresh = 0.9, tau = space_taus(10, tau_c =
  tau_thresh), p = 2)
}
\arguments{
\item{object}{Object of class \code{"lpqr"} (see \code{\link{lpqr}}).
Note that you must use \code{kernel="boxcar"} when building this object,
because \code{ismev}'s \code{gpd.fit()} doesn't allow for weights.}

\item{newdata}{Data frame having at least columns of the covariates, with
rows representing locations you wish to query.}

\item{tau_thresh}{Numeric; quantile index (between 0 and 1) for which
to take as the boundary between the GPD distribution and the nonparametric
"base" distribution.}

\item{tau}{Vector of numeric quantile indices (each between 0 and 1)
for which to evaluate.}

\item{p}{Power of local polynomial, used when fitting the threshold
parameter as well as quantiles with levels less than \code{tau_thresh}.}
}
\value{
A matrix with columns corresponding to the ordered quantile indices
\code{tau}, and rows corresponding to query points (rows) in \code{newdata}.
}
\description{
Uses a kernel smoothing (or more generally, a local polynomial smoothing)
technique to evaluate quantiles for a set of
specified "query points" in the covariate space, with a Generalized
Pareto Distibution (GPD) in the tail. Note that the
scale and shape/EVI parameters are assumed to be constant
over the local covariate space.
}
\details{
For quantile indices \code{tau} that are at most \code{tau_thresh},
local polynomial estimates are given (using
\code{\link{predict.lpqr}}). The same method is applied with
\code{tau=tau_thresh} to determine
the GPD threshold parameter, and then the scale and shape (EVI) parameters
of the GPD are estimated using weighted MLE, with weights determined by the
\code{"lpqr"} \code{object}.
}
\examples{
library(ggplot2)
set.seed(123)
## Get data
x <- runif(1000)*pi
y <- abs(rnorm(1000))*sin(x)*100
z <- x + rexp(1000)*y
dat <- data.frame(x=x, y=y, z=z)
tau <- c(0.9, 0.95, 0.99, 0.999)

## --- Univariate regression ---
setup <- lpqr(z ~ x, data=dat, kernel="boxcar")
xgrid <- seq(0, pi, length.out=20)

yhat <- gpdqr(setup, newdata=data.frame(x=xgrid), tau=tau)
yhatlong <- reshape2::melt(yhat)
names(yhatlong) <- c("x", "tau", "z")
yhatlong$tau <- tau[yhatlong$tau]
yhatlong$x <- xgrid[yhatlong$x]
ggplot(dat, aes(x, z)) +
    geom_point() +
    geom_line(mapping=aes(group=tau),
              data=yhatlong, colour="red")

yhat <- gpdqr(setup, newdata=data.frame(x=xgrid), tau=tau)
yhatlong <- reshape2::melt(yhat)
names(yhatlong) <- c("x", "tau", "z")
yhatlong$tau <- tau[yhatlong$tau]
yhatlong$x <- xgrid[yhatlong$x]
ggplot(dat, aes(x, z)) +
    geom_point() +
    geom_line(mapping=aes(group=tau),
              data=yhatlong, colour="red")

## --- Multivariate regression ---
setup <- lpqr(z ~ x + y, data=dat)
ygrid <- seq(min(y), max(y), length.out=20)
query <- expand.grid(x=xgrid, y=ygrid)

yhat <- gpdqr(setup, newdata=query, tau=tau)
head(yhat)
}
\seealso{
\code{\link{predict.lpqr}}
}
