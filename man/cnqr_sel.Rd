% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cnqr_sel.R
\name{cnqr_sel}
\alias{cnqr_sel}
\title{Select Vines using CNQR}
\usage{
cnqr_sel(rv_list, sc, y, uind, QY = identity)
}
\arguments{
\item{rv_list}{list of \code{'rvine'} objects, each of which may only differ
in the last columns of the copula and copula parameter matrices.}

\item{sc}{Scoring rule to use for the regression, as in the output
of \code{\link{scorer}}.}

\item{y}{Vector of response data.}

\item{uind}{Matrix of independent uniform predictors,
as in the output of \code{\link{pcondseq}}, of the predictors
in the last column of the (common) vine array. If we call "\code{b}" that
column without the first (response) variable, the input matrix should
be the PIT scores of variables
\code{b[1]}; \code{b[2]|b[1]}; \code{b[3]|b[1:2]}; etc.}

\item{QY}{Quantile function of the response \code{y}, which accepts a
vector of values (quantile levels) in (0,1). It should return
quantiles, either in the form of
a vector corresponding to the input,
or in the form of a matrix with columns corresponding to the inputted
quantile levels and rows corresponding to the observations of \code{y}
(thus allowing for each value in \code{y} to come from different
distributions).}
}
\value{
Outputs the "best" entry of \code{rv_list}.
}
\description{
Select from vine models using CNQR. The vines can only differ in the
last columns of their copula and copula parameter matrices, and are
assumed to have the response in the upper-right corner of each vine array.
The vine whose forecasts score optimally is selected.
}
\note{
This function assumes that the inputted vines may only differ in the
last column of the copula and copula parameter matrices, and does not
check to see that this is the case.
}
\examples{
## Get some data, and remove the last variable of its vine.
data(egdat)
a <- egvine$G[, 5]
rv <- subset(egvine, 1:4)
rv <- trunc(rv, 2) # Last cop is indepcop anyway.

## Add the last variable, and link it to the predictors
##  with some copulas.
rv1 <- augment(rv, a=a, cop=rep("frk", 4),
               cpar=rep(list(2), 4))
rv2 <- augment(rv, a=a, cop=rep("bvncop", 4),
               cpar=rep(list(0.7), 4))
rv3 <- augment(rv, a=a, cop=rep("gum", 4),
               cpar=rep(list(2), 4))

## Choose the best one
y <- egdat[, 5]
uind <- pcondseq(egdat, ord=a[-1], rv)
sc <- scorer(tau=space_taus(10))
res <- cnqr_sel(list(rv1, rv2, rv3), sc=sc, y=y, uind=uind)
summary(res)
}
\seealso{
\code{\link{cnqr_est}} for CNQR when the model space is a
parameter space.
}
